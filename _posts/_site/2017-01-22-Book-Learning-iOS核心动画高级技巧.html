<p><strong>阅读iOS核心动画高级技巧读书笔记</strong></p>

<h3 id="section">图层树</h3>

<h3 id="section-1">寄宿图</h3>

<p>iOS使用了以下的坐标系统：</p>

<ul>
  <li>
    <p>点 – 在iOS和Mac OS中最常用的坐标体系。 点就像是虚拟的像素，也被称作逻辑像素。在标准设备上，一个点就是一个像素，但是在Retina设备上，一个点等于2*2个像素。iOS用点作为屏幕的坐标测算体系就是为了在Retina设备和普通设备上能有一致的视觉效果。</p>
  </li>
  <li>
    <p>像素 – 物理像素坐标并不会用来屏幕布局，但是仍然和图片有相对关系。UIImage是一个屏幕分辨率解决方案，所以指定点来度量大小。但是一些底层的图片表示如CGImage就会使用像素，所以你要清楚再Retina设备和普通设备上，他们表现出来的不同的大小。</p>
  </li>
  <li>
    <p>单位 – 对于与图片大小或是图层边界相关的显示，单位坐标是一个方便的度量方式，当大小改变的时候，也不需要再次调整。单位坐标OpenGL这种纹理左边系统中用得很多，Core Animation中也用到了单位坐标。</p>
  </li>
</ul>

<h3 id="section-2">图层几何学</h3>

<h3 id="section-3">视觉效果</h3>

<h3 id="section-4">变换</h3>

<h3 id="section-5">专用图层</h3>

<h3 id="section-6">隐式动画</h3>

<h3 id="section-7">显示动画</h3>

<h3 id="section-8">图层时间</h3>

<h3 id="section-9">缓冲</h3>

<h3 id="section-10">基于定时器的动画</h3>

<h3 id="section-11">性能调优</h3>
<p>当运行一段动画时候，这个过程会被四个分离的阶段打破：</p>

<ul>
  <li>
    <p>布局 - 这是准备你的视图/图层的层级关系，以 及设置图层属性（位置，边框等等）的阶段。</p>
  </li>
  <li>
    <p>显示 - 这是图层的寄宿图片被绘制的阶段。绘制有可能涉及你的 <em>-drawRect:</em>和 <em>-drawLayer:inContext:</em>方法的调用路径。 </p>
  </li>
  <li>
    <p>准备 - 这是Core Animation准备发送动画数据到渲染服务的阶段。这同时也是Core Animation将要执行一些别的事物例如解码动画过程中将要显示的图片的时间点。发送到渲染服务器的时候（图层实际上是由很多小物体组成的特别重量级的对象），太多的图层就会引起CPU的瓶颈。这就限制了一次展示的图层个数。</p>
  </li>
  <li>
    <p>重绘 - 主要由重叠的半透明图层引起。GPU的填充比例（用颜色填充像素的比率）是有限的，所以需要避免重绘（每一帧用相同的像素填充多次）的发生。在现代iOS设备上，GPU都会应对重绘；即使是iPhone 3GS都可以处理高达2.5的重绘比率，并仍然保持60帧率的渲染 （这意味着你可以绘制一个半的整屏的冗余信息，二不影响性能），并且新设备可以处理更多。</p>
  </li>
  <li>
    <p>离屏绘制  - 这发生在当不能直接在屏幕上绘制，并且必须绘制到离屏图片上下文中的时候。 离屏绘制发生在基于CPU或者是GPU的渲染，或者是为离屏图片分配额外内存，以及切换绘制上下文，这些都会降低GPU性能。对于特定图层效果的使用，比如圆角，图层遮罩，阴影或者是图层光栅化都会强制Core Animation提前渲染图层的离屏绘制。但这不意味着你需要避免使用这些效果，只是要明白这会带来性能的负面影响。</p>
  </li>
  <li>
    <p>过大的图片 - 如果视图绘制超出GPU支持的2048<em>2048或者4096</em>4096尺寸的纹理，就必须要用CPU在图层每次显示之前对图片预处理，同样也会降低性能。</p>
  </li>
</ul>

<hr />

<ul>
  <li>
    <p><strong>Color Blended Layers</strong> - 这个选项基于渲染程度对屏幕中的混合区域进行绿到红的高亮（也就是多个半透明图层的叠加）。由于重绘的原因，混合对GPU性能会有影响，同时也是滑动或者动画帧率下降的罪魁祸首之一。</p>
  </li>
  <li>
    <p><strong>ColorHitsGreenAndMissesRed</strong> - 当使用shouldRasterizep属性的时候，耗时的图层绘制会被缓存，然后当做一个简单的扁平图片呈现。当缓存再生的时候这个选项就用红色对栅格化图层进行了高亮。如果缓存频繁再生的话，就意味着栅格化可能会有负面的性能影响了。</p>
  </li>
  <li>
    <p><strong>Color Copied Images</strong> - 有时候寄宿图片的生成意味着Core Animation被强制生成一些图片，然后发送到渲染服务器，而不是简单的指向原始指针。这个选项把这些图片渲染成蓝色。复制图片对内存和CPU使用来说都是一项非常昂贵的操作，所以应该尽可能的避免。</p>
  </li>
  <li>
    <p><strong>Color Immediately</strong> - 通常Core Animation Instruments以每毫秒10次的频率更新图层调试颜色。 对某些效果来说，这显然太慢了。 这个选项就可以用来设置每帧都更新。</p>
  </li>
  <li>
    <p><strong>Color Misaligned Images</strong> - 这里会高亮那些被缩放或者拉伸以及没有正确对齐到像素边界的图片(也就是非整形坐标)。 这些中的大多数通常都会导致图片的不正常缩放，如果把一张大图当缩略图显示，或者不正确地模糊图像，那么这个选项将会帮你识别出问题所在。  </p>
  </li>
  <li>
    <p><strong>Color Offscreen-Rendered Yellow</strong> - 这里会把那些需要离屏渲染的图层高亮成黄色。这些图层很可能需要用 shadowPath 或者 shouldRasterize来优化。</p>
  </li>
  <li>
    <p><strong>Color OpenGL Fast Path Blue</strong> - 这个选项会对任何直接使用OpenGL绘制的图层进行高亮。如果仅仅使用UIKit或者Core Animation的API，那么不会有任何效果。如果使用GLKView或者CAEAGLayer，那如果不显示蓝色块的话，就意味着你正在强制CPU渲染额外的纹理，而不是绘制到屏幕。</p>
  </li>
  <li>
    <p><strong>Flash Updated Regions</strong> - 这个选项会对重绘的内容高亮成黄色(也就是任何在软件层面使用Core Graphics绘制的图层)。这种绘图的速度很慢。如果频繁发生这种情况的话，这意味着有一个隐藏的bug或者通过增加缓存或者使用替代方案会有提升性能的空间。</p>
  </li>
</ul>

<hr />

<h3 id="section-12">高效绘图</h3>

<h3 id="io">图像IO</h3>

<h3 id="section-13">图层性能</h3>

